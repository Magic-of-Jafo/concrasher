import { NextResponse } from 'next/server';
import { z } from 'zod';
import { db } from '@/lib/db';
import { PriceTierSchema } from '@/lib/validators';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";

// Define a schema for the array of price tiers from the request body
// id and conventionId are omitted as id is generated by DB, and conventionId is from URL param.
// The PriceTierSchema from validators.ts already handles amount preprocessing.
const PriceTiersArraySchema = z.array(
  PriceTierSchema.omit({ id: true, conventionId: true })
);

export async function PUT(
  request: Request,
  { params }: { params: { id: string } } // Convention ID from path
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }
    const currentUserId = session.user.id;

    const conventionId = params.id;
    if (!conventionId) {
      return NextResponse.json(
        { message: 'Convention ID is required' },
        { status: 400 }
      );
    }

    // Fetch convention series organizer for authorization
    const conventionData = await db.convention.findUnique({
      where: { id: conventionId },
      select: {
        series: { // Select the related series
          select: {
            organizerUserId: true // Select the organizerUserId from the series
          }
        }
      }
    });

    if (!conventionData) {
      return NextResponse.json({ message: 'Convention not found' }, { status: 404 });
    }

    // Authorization check: user must be the organizer of the convention's series
    // Also ensure that conventionData.series is not null before accessing organizerUserId
    if (!conventionData.series || conventionData.series.organizerUserId !== currentUserId) {
      return NextResponse.json(
        { message: 'Forbidden: You are not the organizer of this convention series or series data is missing.' },
        { status: 403 }
      );
    }

    const json = await request.json();
    // Expecting { priceTiers: [...] } in the body from the client
    const parseResult = PriceTiersArraySchema.safeParse(json.priceTiers);

    if (!parseResult.success) {
      return NextResponse.json(
        { message: 'Invalid input for price tiers', errors: parseResult.error.format() },
        { status: 400 }
      );
    }

    const validatedPriceTiers = parseResult.data;

    const savedTiers = await db.$transaction(async (prisma) => {
      // Delete existing price tiers for this convention
      await prisma.priceTier.deleteMany({
        where: { conventionId: conventionId },
      });

      // Create new price tiers
      // The 'order' field from validatedPriceTiers reflects the user's desired order
      const createPromises = validatedPriceTiers.map((tier) =>
        prisma.priceTier.create({
          data: {
            conventionId: conventionId, // Assign the conventionId from the path
            label: tier.label,
            amount: tier.amount, // Amount is already a number due to PriceTierSchema preprocessing
            order: tier.order,
          },
        })
      );
      return Promise.all(createPromises);
    });

    return NextResponse.json(savedTiers, { status: 200 });
  } catch (error) {
    console.error('[API/PricingTiers/PUT] Error saving price tiers:', error);
    // Note: ZodError during parseResult.safeParse is handled above.
    // This catch block handles other unexpected errors.
    return NextResponse.json(
      { message: 'An unexpected error occurred while saving price tiers.' },
      { status: 500 }
    );
  }
} 
import { NextResponse } from 'next/server';
import { z } from 'zod';
import prisma from '@/lib/prisma';
import { PriceTierSchema } from '@/lib/validators';
import { Prisma } from '@prisma/client';

// Updated schema for the request body
// Each tier can optionally have an ID (for updates)
const PriceTierUpsertSchema = PriceTierSchema.omit({ conventionId: true }).extend({
  id: z.string().cuid().optional(), // CUID if updating, undefined if new
});

const PriceTiersPayloadSchema = z.object({
  priceTiers: z.array(PriceTierUpsertSchema),
});

// Helper function to ensure amount is a number (it might come as string from form)
// and ensure conventionId is present for creation/update context (though not directly on schema)
const normalizePriceTierData = (tier: z.infer<typeof PriceTierUpsertSchema>, conventionId: string) => ({
  id: tier.id, // Preserve id if present
  label: tier.label.trim(),
  amount: Number(tier.amount),
  order: tier.order,
  conventionId: conventionId,
});

export async function PUT(
  request: Request,
  { params }: { params: { id: string } } // Expects id from path
) {
  const { id: conventionId } = params; // Use id from path as conventionId

  if (!conventionId) {
    return NextResponse.json({ message: 'Convention ID is required' }, { status: 400 });
  }

  try {
    const body = await request.json();
    const validation = PriceTiersPayloadSchema.safeParse(body);

    if (!validation.success) {
      console.error('Price Tiers API Validation Error:', validation.error.errors);
      return NextResponse.json({ message: 'Invalid request payload for price tiers', errors: validation.error.errors }, { status: 400 });
    }

    const { priceTiers: incomingTiers } = validation.data;

    const results = await prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // 1. Get existing tiers for this convention
      const existingTiers = await tx.priceTier.findMany({
        where: { conventionId },
      });
      const existingTierIds = existingTiers.map(t => t.id);

      // 2. Identify tiers to delete:
      // Tiers that exist in the database but their IDs are not present in the incoming payload.
      const incomingTierIdsWithId = incomingTiers
        .map(t => t.id)
        .filter(id => id !== undefined) as string[];
      
      const tierIdsToDelete = existingTierIds.filter(id => !incomingTierIdsWithId.includes(id));

      if (tierIdsToDelete.length > 0) {
        // First, delete PriceDiscounts associated with the tiers being deleted
        await tx.priceDiscount.deleteMany({
          where: { priceTierId: { in: tierIdsToDelete } },
        });
        // Then, delete the tiers themselves
        await tx.priceTier.deleteMany({
          where: { id: { in: tierIdsToDelete } },
        });
      }

      // 3. Upsert (create or update) incoming tiers
      // The order of operations matters if tiers reference each other, but here they are independent other than 'order' field.
      // We process them in the order they are received.
      const upsertedTiers = [];
      for (const incomingTier of incomingTiers) {
        // Ensure data is in the correct format (e.g., amount is a number)
        const normalizedData = normalizePriceTierData(incomingTier, conventionId);
        
        const upsertedTier = await tx.priceTier.upsert({
          where: { 
            // If 'normalizedData.id' is provided, Prisma attempts to find and update that record.
            // If 'normalizedData.id' is undefined (new tier) or not found, 
            // this specific where clause (e.g., using a clearly non-existent ID) ensures the 'create' block is used.
            id: normalizedData.id || '---ensure-create-path-for-new-tier---' 
          },
          update: { // Fields to update if the tier exists
            label: normalizedData.label,
            amount: normalizedData.amount,
            order: normalizedData.order,
            // conventionId should not change for an existing tier being updated
          },
          create: { // Fields to use if creating a new tier
            // id will be auto-generated by Prisma because it's not specified here
            label: normalizedData.label,
            amount: normalizedData.amount,
            order: normalizedData.order,
            conventionId: normalizedData.conventionId, // Set for new tiers
          },
        });
        upsertedTiers.push(upsertedTier);
      }
      
      // Return the final state of tiers for this convention, ordered by 'order'
      return tx.priceTier.findMany({
        where: { conventionId },
        orderBy: { order: 'asc' },
      });
    });

    return NextResponse.json(results, { status: 200 });

  } catch (error) {
    console.error('Error saving price tiers:', error);
    // ZodError should be caught by validation.success check, but as a fallback:
    if (error instanceof z.ZodError) { 
      return NextResponse.json({ message: 'Validation error during tier processing', errors: error.errors }, { status: 400 });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        // Handle known Prisma errors (e.g., unique constraints, foreign keys)
        console.error('Prisma Error Code:', error.code);
        return NextResponse.json({ message: `Database error: ${error.message}`, code: error.code }, { status: 409 }); // Conflict or Bad Request
    }
    return NextResponse.json({ message: 'An internal server error occurred while saving price tiers' }, { status: 500 });
  }
} 